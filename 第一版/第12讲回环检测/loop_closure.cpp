#include "DBoW3/DBoW3.h"
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <iostream>
#include <vector>
#include <string>

using namespace cv;
using namespace std;

/***************************************************
 * 本节演示了如何根据前面训练的字典计算相似性评分
 * 演示了如何使用字典检测回环
 * ************************************************/
int main( int argc, char** argv )
{
    // read the images and database  
    //加载字典
    cout<<"reading database"<<endl;
//    DBoW3::Vocabulary vocab("./vocabulary.yml.gz");
     DBoW3::Vocabulary vocab("./vocab_larger.yml.gz");  // use large vocab if you want:
    if ( vocab.empty() )
    {
        cerr<<"Vocabulary does not exist."<<endl;
        return 1;
    }

    //读取图片
    cout<<"reading images... "<<endl;
    vector<Mat> images; 
    for ( int i=0; i<10; i++ )
    {
        string path = "./data/"+to_string(i+1)+".png";
        images.push_back( imread(path) );
    }
    
    // NOTE: in this case we are comparing images with a vocabulary generated by themselves, this may leed to overfitting.  
    // detect ORB features
    //给图片计算描述子
    cout<<"detecting ORB features ... "<<endl;
    Ptr< Feature2D > detector = ORB::create();
    vector<Mat> descriptors;
    for ( Mat& image:images )
    {
        vector<KeyPoint> keypoints; 
        Mat descriptor;
        detector->detectAndCompute( image, Mat(), keypoints, descriptor );
        descriptors.push_back( descriptor );
    }
    
    // we can compare the images directly or we can compare one image to a database 
    // images :
    //图片与图片
    cout<<"comparing images with images "<<endl;
    for ( int i=0; i<images.size(); i++ )
    {
        //1.先取出一张图片的描述子，使用字典 计算其词向量
        DBoW3::BowVector v1;
        vocab.transform( descriptors[i], v1 );
        //2.再逐个取出剩下图片的描述子，使用字典 计算其词向量
        for ( int j=i; j<images.size(); j++ )
        {
            DBoW3::BowVector v2;
            vocab.transform( descriptors[j], v2 );
            //3.使用字典计算 两个词向量的分
            double score = vocab.score(v1, v2);
            cout<<"image "<<i<<" vs image "<<j<<" : "<<score<<endl;
        }
        cout<<endl;
    }

    //图片与数据库
    // or with database 
    cout<<"comparing images with database "<<endl;
    //1.创建一个数据库
    DBoW3::Database db( vocab, false, 0);
    //2.将描述子添加进数据库中
    for ( int i=0; i<descriptors.size(); i++ )
        db.add(descriptors[i]);
    cout<<"database info: "<<db<<endl;
    //3.逐个取出  描述子，将描述子放进数据库中进行查找结果。  返回指定数量的结果（按照评分的高低输出）
    for ( int i=0; i<descriptors.size(); i++ )
    {
        // QueryResults 继承自 std::vector<Result>
        //  Result对象具有 Entry id、 double Score 等成员变量
        DBoW3::QueryResults ret;
        db.query( descriptors[i], ret, 4);      // max result=4
        cout<<"searching for image "<<i<<" returns "<<ret<<endl<<endl;
        //
//        for (int j = 0; j < ret.size(); ++j) {
//            cout<<ret[j]<<endl;
//            cout<<ret[j].Id<<" "<<ret[j].bhatScore<<" "<<ret[j].chiScore<<" "<<ret[j].Score<<endl;
//        }
//        cout<<"------------"<<endl;
    }
    /*
     * 相机开始时，逐个将每一帧（关键帧）的描述子添加进数据库中。
     * 然后把每一帧在数据库中进行查找，如果查找到评分很高的就说明可能是回环。
     * （比如：如果是查找的id和自己的id很接近，说明是附近的帧，不做回环处理。
     *      如果检测到前方远处的帧与当前的评分很高有可能是回环，那么再看看是不是当前连续几帧和那个地方的连续几帧都回环了，如果连续之间都检测到了，可以认为回环了。
     *      然后，根据回环帧之间的id取出这两帧，计算这两帧的sim3，然后做全局优化）
     * */
    cout<<"done."<<endl;
}